<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AetherDrop</title>
<link rel="icon" href="data:,">
<style>
:root{
  --bg1:#0b1220; --bg2:#071226;
  --card:#0e1720; --muted:#98a6b0;
  --accent:#6EE7C8; --accent-2:#39C9A9;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6f7f2}
.container{max-width:920px;margin:36px auto;padding:20px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 12px 38px rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.02)}
.header{display:flex;align-items:center;gap:14px}
.logo{width:62px;height:62px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;color:#052022;font-weight:800;font-size:22px}
.title{font-size:20px;font-weight:700}
.lead{color:var(--muted);margin-top:6px;font-size:13px}
.grid{display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:20px}
.card{background:transparent;padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.02)}
.controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
.btn{
  background:linear-gradient(90deg,var(--accent),var(--accent-2));
  color:#042022;border:none;padding:12px 14px;border-radius:10px;font-weight:700;cursor:pointer;
  box-shadow:0 8px 20px rgba(41,163,142,0.06);
}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
.input{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);background:#06121a;color:#d6f6ef;width:100%}
.code{font-weight:800;letter-spacing:6px;background:rgba(255,255,255,0.02);padding:8px 12px;border-radius:10px;font-size:20px}
.small{font-size:13px;color:var(--muted)}
.progress{height:12px;border-radius:10px;background:rgba(255,255,255,0.03);overflow:hidden;width:100%;margin-top:10px}
.progress > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent-2))}
.hidden{display:none}
.download-card{display:flex;align-items:center;gap:12px;padding:12px;border-radius:12px;background:linear-gradient(90deg, rgba(255,255,255,0.015), transparent);border:1px solid rgba(255,255,255,0.02)}
.file-meta{display:flex;flex-direction:column;min-width:0}
.file-name{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.file-size{font-size:13px;color:var(--muted);margin-top:4px}
.download-btn{margin-left:auto;background:linear-gradient(90deg,var(--accent),var(--accent-2));padding:10px 12px;border-radius:10px;color:#042022;font-weight:700;border:none;cursor:pointer}
.small-ghost{background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:var(--muted)}
.footer{font-size:12px;color:var(--muted);margin-top:14px}
@media (max-width:900px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="logo">AD</div>
    <div>
      <div class="title">AetherDrop</div>
      <div class="lead">Direct peer-to-peer file transfer over local Wi-Fi. No storage — files go straight device-to-device.</div>
    </div>
    <div style="margin-left:auto" class="small">v1</div>
  </div>

  <div class="grid">
    <div class="card">
      <!-- Landing: only Send / Receive -->
      <div id="landing" class="">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Quick start</div>
          <div class="small">No uploads. P2P only.</div>
        </div>
        <div class="controls" style="margin-top:18px">
          <button id="sendBtn" class="btn">Send</button>
          <button id="recvBtn" class="btn ghost">Receive</button>
        </div>
      </div>

      <!-- Send panel -->
      <div id="sendPanel" class="hidden" style="margin-top:16px">
        <div style="font-weight:700">Send — choose a file</div>
        <input id="fileInput" type="file" class="input" style="margin-top:10px"/>
        <div style="margin-top:12px" class="small">Share this 4-digit code with the receiver</div>
        <div style="margin-top:10px;display:flex;align-items:center;gap:8px">
          <div class="code" id="roomCode">— — — —</div>
          <button id="copyCodeBtn" class="small-ghost">Copy</button>
        </div>

        <div class="controls" style="margin-top:12px">
          <button id="startShare" class="btn">Start sharing</button>
          <button id="cancelShare" class="btn ghost">Back</button>
        </div>

        <div class="progress hidden" id="sendProgressWrap"><i id="sendBar"></i></div>
      </div>

      <!-- Receive panel -->
      <div id="recvPanel" class="hidden" style="margin-top:16px">
        <div style="font-weight:700">Receive — enter 4-digit code</div>
        <input id="joinCode" class="input" placeholder="Enter 4-digit code" style="margin-top:10px"/>
        <div class="controls" style="margin-top:12px">
          <button id="joinBtn" class="btn">Connect</button>
          <button id="cancelJoin" class="btn ghost">Back</button>
        </div>

        <div class="small" style="margin-top:10px">Incoming file</div>
        <div id="incomingPlace" style="margin-top:10px"></div>

        <div class="progress hidden" id="recvProgressWrap"><i id="recvBar"></i></div>
      </div>

      <div class="footer">For best results use devices on same Wi-Fi and keep both browsers open until transfer completes.</div>
    </div>

    <div class="card">
      <div style="font-weight:700">Status</div>
      <div style="margin-top:10px" class="small">Peer: <span id="peerState">Idle</span></div>
      <div style="margin-top:8px" class="small">Transfer: <span id="transferState">Idle</span></div>
      <div style="margin-top:12px" class="small">(Server URL hidden from UI — paired via code)</div>
    </div>
  </div>
</div>

<script>
/*
  AetherDrop frontend (fixed)
  - Uses SIGNALING_SERVER (internal)
  - Click Send shows code immediately
  - Start sharing / Connect handle WS + WebRTC correctly
  - Robust waits for WS open and DataChannel open before sending
*/

const SIGNALING_SERVER = 'wss://aetherdrop.onrender.com';

const sendBtn = document.getElementById('sendBtn');
const recvBtn = document.getElementById('recvBtn');
const landing = document.getElementById('landing');
const sendPanel = document.getElementById('sendPanel');
const recvPanel = document.getElementById('recvPanel');
const fileInput = document.getElementById('fileInput');
const roomCodeEl = document.getElementById('roomCode');
const copyCodeBtn = document.getElementById('copyCodeBtn');
const startShareBtn = document.getElementById('startShare');
const cancelShare = document.getElementById('cancelShare');
const joinBtn = document.getElementById('joinBtn');
const joinCode = document.getElementById('joinCode');
const cancelJoin = document.getElementById('cancelJoin');
const incomingPlace = document.getElementById('incomingPlace');
const sendProgressWrap = document.getElementById('sendProgressWrap');
const recvProgressWrap = document.getElementById('recvProgressWrap');
const sendBar = document.getElementById('sendBar');
const recvBar = document.getElementById('recvBar');
const peerState = document.getElementById('peerState');
const transferState = document.getElementById('transferState');

let ws = null;
let pc = null;
let dataChannel = null;
let isSender = false;
let currentRoom = null;
const CHUNK = 64 * 1024; // 64KB chunks

// UI events
sendBtn.onclick = () => showPanel('send');
recvBtn.onclick = () => showPanel('recv');
cancelShare.onclick = () => showPanel('home');
cancelJoin.onclick = () => showPanel('home');
copyCodeBtn.onclick = () => {
  if(currentRoom) navigator.clipboard.writeText(currentRoom).then(()=>alert('Code copied'));
};
startShareBtn.onclick = startSharing;
joinBtn.onclick = joinRoom;

// UI functions
function showPanel(name){
  if(name === 'home'){
    landing.classList.remove('hidden');
    sendPanel.classList.add('hidden');
    recvPanel.classList.add('hidden');
    cleanup();
  } else if(name === 'send'){
    landing.classList.add('hidden');
    sendPanel.classList.remove('hidden');
    recvPanel.classList.add('hidden');
    isSender = true;
    currentRoom = genCode();
    roomCodeEl.textContent = currentRoom;
    setPeer('Idle'); setTransfer('Idle');
  } else if(name === 'recv'){
    landing.classList.add('hidden');
    sendPanel.classList.add('hidden');
    recvPanel.classList.remove('hidden');
    isSender = false;
    setPeer('Idle'); setTransfer('Idle');
  }
}

function setPeer(s){ peerState.textContent = s; }
function setTransfer(s){ transferState.textContent = s; }

function genCode(){ return (Math.floor(1000 + Math.random()*9000)).toString(); }

// Connect WS and join room
function openWsAndJoin(room){
  return new Promise((resolve, reject) => {
    if(ws && ws.readyState === WebSocket.OPEN){
      ws.send(JSON.stringify({ type:'join', room }));
      return resolve();
    }

    ws = new WebSocket(SIGNALING_SERVER);

    ws.onopen = () => {
      setPeer('Signalling connected');
      ws.send(JSON.stringify({ type:'join', room }));
      resolve();
    };

    ws.onmessage = async (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        if(msg.type === 'ready'){
          setPeer('Peer arrived');
        } else if(msg.type === 'signal' && msg.signal){
          await handleSignal(msg.signal);
        } else if(msg.type === 'peer-left'){
          alert('Peer disconnected');
          cleanup();
        }
      } catch(e){
        console.warn('WS parse error', e);
      }
    };

    ws.onerror = (e) => {
      console.error('WS error', e);
      setPeer('WS error');
      reject(e);
    };

    ws.onclose = () => setPeer('WS closed');
  });
}

function wsSend(obj){
  if(!ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify(obj));
}

// create RTCPeerConnection and set up channels/callbacks
function createPeer(initiator){
  pc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });

  pc.onicecandidate = (ev) => {
    if(ev.candidate) wsSend({ type:'signal', room: currentRoom, signal: { candidate: ev.candidate } });
  };

  pc.onconnectionstatechange = () => {
    setPeer(pc.connectionState);
    if(pc.connectionState === 'failed' || pc.connectionState === 'disconnected'){
      setTransfer('Disconnected');
    }
  };

  if(initiator){
    dataChannel = pc.createDataChannel('aether-file');
    setupDataChannel();
    pc.createOffer().then(offer => pc.setLocalDescription(offer)).then(() => {
      wsSend({ type:'signal', room: currentRoom, signal: { sdp: pc.localDescription } });
      setPeer('Offer sent');
    }).catch(e => console.error('Offer error', e));
  } else {
    pc.ondatachannel = (ev) => {
      dataChannel = ev.channel;
      setupDataChannel();
    };
  }
}

async function handleSignal(signal){
  if(signal.sdp){
    await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
    if(signal.sdp.type === 'offer'){
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      wsSend({ type:'signal', room: currentRoom, signal: { sdp: pc.localDescription } });
      setPeer('Answer sent');
    } else {
      setPeer('Remote SDP applied');
    }
  }
  if(signal.candidate){
    try{
      await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
    }catch(e){ console.warn('addIce failed', e); }
  }
}

// DataChannel behavior
let incomingInfo = null;
let incomingBuffers = [];
let incomingReceived = 0;

function setupDataChannel(){
  dataChannel.binaryType = 'arraybuffer';

  dataChannel.onopen = () => {
    setTransfer('Channel open');
    log('DataChannel open');
  };

  dataChannel.onmessage = (ev) => {
    if(typeof ev.data === 'string'){
      try{
        const m = JSON.parse(ev.data);
        if(m.type === 'meta'){
          incomingInfo = { name: m.name, size: m.size };
          incomingBuffers = []; incomingReceived = 0;
          recvProgressWrap.classList.remove('hidden'); recvBar.style.width='0%';
          setTransfer(`Receiving ${incomingInfo.name}`);
          renderIncomingPlaceholder(incomingInfo.name, incomingInfo.size);
        } else if(m.type === 'done'){
          const blob = new Blob(incomingBuffers);
          const url = URL.createObjectURL(blob);
          showReceivedFile(incomingInfo.name, incomingInfo.size, url);
          setTransfer('Received');
          recvBar.style.width = '100%';
        }
      }catch(e){ console.warn('string parse', e); }
      return;
    }

    // chunk
    incomingBuffers.push(ev.data);
    incomingReceived += ev.data.byteLength;
    if(incomingInfo && incomingInfo.size){
      const pct = Math.round((incomingReceived / incomingInfo.size) * 100);
      recvBar.style.width = pct + '%';
    }
  };

  dataChannel.onclose = () => setTransfer('Channel closed');
  dataChannel.onerror = (e) => { console.error('DC error', e); setTransfer('Channel error'); };
}

// Start sharing (sender)
async function startSharing(){
  const file = fileInput.files[0];
  if(!file) return alert('Pick a file first');
  isSender = true;
  if(!currentRoom) currentRoom = genCode();
  roomCodeEl.textContent = currentRoom;
  await openWsAndJoin(currentRoom);
  createPeer(true);

  // wait for data channel open (up to 20s)
  try{
    await waitForCondition(()=>dataChannel && dataChannel.readyState === 'open', 20000);
  }catch(e){
    alert('Failed to open data channel. Make sure receiver entered code and try again.');
    return;
  }

  // send file
  sendProgressWrap.classList.remove('hidden'); sendBar.style.width='0%';
  dataChannel.send(JSON.stringify({ type:'meta', name: file.name, size: file.size }));

  const reader = new FileReader();
  let offset = 0;
  reader.onerror = () => { setTransfer('Read error'); };

  reader.onload = (e) => {
    dataChannel.send(e.target.result);
    offset += e.target.result.byteLength;
    const pct = Math.round((offset / file.size) * 100);
    sendBar.style.width = pct + '%';
    if(offset < file.size) readSlice(offset);
    else {
      dataChannel.send(JSON.stringify({ type:'done' }));
      setTransfer('Sent');
    }
  };

  const readSlice = o => {
    const slice = file.slice(o, o + CHUNK);
    reader.readAsArrayBuffer(slice);
  };

  readSlice(0);
}

// Join room as receiver
async function joinRoom(){
  const code = (joinCode.value || '').trim();
  if(!/^\d{4}$/.test(code)) return alert('Enter valid 4-digit code');
  currentRoom = code;
  await openWsAndJoin(currentRoom);
  createPeer(false);
  setTransfer('Waiting for offer...');
}

// small helper: wait for condition
function waitForCondition(fn, timeout = 10000){
  return new Promise((resolve,reject) => {
    const start = Date.now();
    (function check(){
      try{ if(fn()) return resolve(); }catch(e){}
      if(Date.now() - start > timeout) return reject(new Error('timeout'));
      setTimeout(check, 200);
    })();
  });
}

// render incoming file placeholder
function renderIncomingPlaceholder(name, size){
  incomingPlace.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.className = 'download-card';
  const meta = document.createElement('div');
  meta.className = 'file-meta';
  const nm = document.createElement('div'); nm.className = 'file-name'; nm.textContent = name;
  const sz = document.createElement('div'); sz.className = 'file-size'; sz.textContent = humanFileSize(size);
  meta.appendChild(nm); meta.appendChild(sz);
  const btn = document.createElement('button'); btn.className = 'download-btn'; btn.textContent = 'Receiving...'; btn.disabled = true;
  wrap.appendChild(meta); wrap.appendChild(btn);
  incomingPlace.appendChild(wrap);
}

// show received file and download button
function showReceivedFile(name, size, url){
  incomingPlace.innerHTML = '';
  const wrap = document.createElement('div'); wrap.className = 'download-card';
  const meta = document.createElement('div'); meta.className = 'file-meta';
  const nm = document.createElement('div'); nm.className = 'file-name'; nm.textContent = name;
  const sz = document.createElement('div'); sz.className = 'file-size'; sz.textContent = humanFileSize(size);
  meta.appendChild(nm); meta.appendChild(sz);
  const a = document.createElement('a'); a.href = url; a.download = name; a.className = 'download-btn'; a.textContent = 'Download';
  a.onclick = () => setTransfer('Downloaded');
  wrap.appendChild(meta); wrap.appendChild(a);
  incomingPlace.appendChild(wrap);
}

function humanFileSize(size){
  if(size < 1024) return size + ' B';
  const i = Math.floor(Math.log(size)/Math.log(1024));
  const sizes = ['B','KB','MB','GB','TB'];
  return (size/Math.pow(1024,i)).toFixed(1) + ' ' + sizes[i];
}

function cleanup(){
  if(ws){ try{ ws.close(); }catch(e){} ws = null; }
  if(pc){ try{ pc.close(); }catch(e){} pc = null; }
  dataChannel = null;
  incomingInfo = null; incomingBuffers = []; incomingReceived = 0;
  sendProgressWrap.classList.add('hidden'); recvProgressWrap.classList.add('hidden');
  sendBar.style.width = '0%'; recvBar.style.width = '0%';
  incomingPlace.innerHTML = '';
  setPeer('Idle'); setTransfer('Idle');
  currentRoom = null;
}

function log(...a){ console.log('[AetherDrop]', ...a); }

// initialize on load
showPanel('home');
window.addEventListener('beforeunload', cleanup);
</script>
</body>
</html>
